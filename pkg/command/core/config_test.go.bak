// ABOUTME: Unit tests for the config command, covering all subcommands and edge cases
// ABOUTME: Tests list, get, set, validate, export/import, and profile operations

package core

import (
	"bytes"
	"context"
	"strings"
	"testing"

	"github.com/lexlapax/magellai/pkg/command"
	"github.com/lexlapax/magellai/pkg/config"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestConfigCommand_Execute(t *testing.T) {
	tests := []struct {
		name           string
		args           []string
		flags          map[string]interface{}
		setupConfig    func(*config.Config)
		expectedOutput string
		expectedError  string
		outputFormat   string
	}{
		// Basic commands
		{
			name: "show current config",
			args: []string{},
			setupManager: func(m *config.Manager) {
				m.SetDefaultProvider("openai")
				m.SetDefaultModel("gpt-4")
			},
			expectedOutput: "Current configuration:\n  Provider: openai\n  Model: gpt-4\n  Profile: default\n",
		},
		{
			name:           "show current config JSON",
			args:           []string{},
			outputFormat:   "json",
			expectedOutput: `"provider": "openai"`,
		},
		
		// List command
		{
			name:           "list all config",
			args:           []string{"list"},
			expectedOutput: "Configuration settings:",
		},
		{
			name:           "list all config JSON",
			args:           []string{"list"},
			flags:          map[string]interface{}{"format": "json"},
			expectedOutput: "{",
		},
		
		// Get command
		{
			name: "get existing key",
			args: []string{"get", "provider"},
			setupManager: func(m *config.Manager) {
				m.SetDefaultProvider("openai")
			},
			expectedOutput: "provider: openai",
		},
		{
			name:          "get missing key",
			args:          []string{"get", "nonexistent"},
			expectedError: "key not found: nonexistent",
		},
		{
			name:          "get without key",
			args:          []string{"get"},
			expectedError: "missing required argument 'key' for command 'config get'",
		},
		
		// Set command
		{
			name:           "set provider",
			args:           []string{"set", "provider", "anthropic"},
			expectedOutput: "Provider set to: anthropic",
		},
		{
			name:           "set model with provider",
			args:           []string{"set", "model", "openai/gpt-4"},
			expectedOutput: "Model set to: openai/gpt-4",
		},
		{
			name:           "set arbitrary key",
			args:           []string{"set", "debug", "true"},
			expectedOutput: "debug set to: true",
		},
		{
			name:          "set without value",
			args:          []string{"set", "key"},
			expectedError: "missing required argument 'key value' for command 'config set'",
		},
		
		// Validate command
		{
			name:           "validate valid config",
			args:           []string{"validate"},
			expectedOutput: "Configuration is valid",
		},
		
		// Export command
		{
			name:           "export config",
			args:           []string{"export"},
			expectedOutput: "provider:",
		},
		{
			name:           "export config JSON",
			args:           []string{"export"},
			flags:          map[string]interface{}{"format": "json"},
			expectedOutput: "{",
		},
		
		// Import command
		{
			name:          "import without filename",
			args:          []string{"import"},
			expectedError: "missing required argument 'filename' for command 'config import'",
		},
		
		// Profile commands
		{
			name:           "list profiles",
			args:           []string{"profiles"},
			expectedOutput: "Available profiles:\n  * default (current)\n",
		},
		{
			name:           "list profiles subcommand",
			args:           []string{"profiles", "list"},
			expectedOutput: "Available profiles:\n  * default (current)\n",
		},
		{
			name:           "create profile",
			args:           []string{"profiles", "create", "work"},
			expectedOutput: "Created profile: work",
		},
		{
			name:          "create profile without name",
			args:          []string{"profiles", "create"},
			expectedError: "missing required argument 'name' for command 'config profiles create'",
		},
		{
			name:           "switch profile",
			args:           []string{"profiles", "switch", "default"},
			expectedOutput: "Switched to profile: default",
		},
		{
			name:          "switch profile without name",
			args:          []string{"profiles", "switch"},
			expectedError: "missing required argument 'name' for command 'config profiles switch'",
		},
		{
			name: "delete profile",
			args: []string{"profiles", "delete", "test"},
			setupManager: func(m *config.Manager) {
				m.CreateProfile("test")
			},
			expectedOutput: "Deleted profile: test",
		},
		{
			name:          "delete profile without name",
			args:          []string{"profiles", "delete"},
			expectedError: "missing required argument 'name' for command 'config profiles delete'",
		},
		{
			name: "export profile",
			args: []string{"profiles", "export", "default"},
			expectedOutput: "provider:",
		},
		{
			name:          "export profile without name",
			args:          []string{"profiles", "export"},
			expectedError: "missing required argument 'name' for command 'config profiles export'",
		},
		
		// Invalid commands
		{
			name:          "invalid subcommand",
			args:          []string{"invalid"},
			expectedError: "invalid argument 'invalid' for command 'config'",
		},
		{
			name:          "invalid profile subcommand",
			args:          []string{"profiles", "invalid"},
			expectedError: "invalid argument 'invalid' for command 'config profiles'",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a test config
			cfg := createTestConfig(t)
			if tt.setupConfig != nil {
				tt.setupConfig(cfg)
			}

			cmd := NewConfigCommand(cfg)

			ctx := context.Background()
			var stdout, stderr bytes.Buffer
			exec := &command.ExecutionContext{
				Args:   tt.args,
				Flags:  tt.flags,
				Stdout: &stdout,
				Stderr: &stderr,
				Data:   make(map[string]interface{}),
			}

			if tt.outputFormat != "" {
				exec.Data["outputFormat"] = tt.outputFormat
			}

			err := cmd.Execute(ctx, exec)

			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
			} else {
				require.NoError(t, err)
				output, ok := exec.Data["output"].(string)
				require.True(t, ok)
				assert.Contains(t, output, tt.expectedOutput)
			}
		})
	}
}

func TestConfigCommand_Metadata(t *testing.T) {
	cmd := NewConfigCommand(nil)
	meta := cmd.Metadata()

	assert.Equal(t, "config", meta.Name)
	assert.Contains(t, meta.Aliases, "cfg")
	assert.Equal(t, command.CategoryShared, meta.Category)
	assert.NotEmpty(t, meta.Description)
	assert.NotEmpty(t, meta.LongDescription)
	assert.Contains(t, meta.LongDescription, "list")
	assert.Contains(t, meta.LongDescription, "get")
	assert.Contains(t, meta.LongDescription, "set")
	assert.Contains(t, meta.LongDescription, "validate")
	assert.Contains(t, meta.LongDescription, "export")
	assert.Contains(t, meta.LongDescription, "import")
	assert.Contains(t, meta.LongDescription, "profiles")
	
	// Check flags
	assert.Len(t, meta.Flags, 1)
	formatFlag := meta.Flags[0]
	assert.Equal(t, "format", formatFlag.Name)
	assert.Equal(t, "f", formatFlag.Short)
	assert.Equal(t, command.FlagTypeString, formatFlag.Type)
	assert.Equal(t, "text", formatFlag.Default)
}

func TestConfigCommand_Validate(t *testing.T) {
	tests := []struct {
		name          string
		manager       *config.Manager
		expectedError string
	}{
		{
			name:    "valid with manager",
			manager: createTestConfigManager(t),
		},
		{
			name:          "invalid without manager",
			manager:       nil,
			expectedError: "config manager not initialized",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cmd := NewConfigCommand(tt.manager)
			err := cmd.Validate()

			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
			} else {
				require.NoError(t, err)
			}
		})
	}
}

func TestConfigCommand_ProfileOperations(t *testing.T) {
	manager := createTestConfigManager(t)
	cmd := NewConfigCommand(manager)
	ctx := context.Background()

	// Create a test profile
	exec := &command.ExecutionContext{
		Args: []string{"profiles", "create", "test"},
		Data: make(map[string]interface{}),
	}
	err := cmd.Execute(ctx, exec)
	require.NoError(t, err)
	assert.Contains(t, exec.Data["output"], "Created profile: test")

	// List profiles
	exec = &command.ExecutionContext{
		Args: []string{"profiles", "list"},
		Data: make(map[string]interface{}),
	}
	err = cmd.Execute(ctx, exec)
	require.NoError(t, err)
	output := exec.Data["output"].(string)
	assert.Contains(t, output, "default (current)")
	assert.Contains(t, output, "test")

	// Switch to test profile
	exec = &command.ExecutionContext{
		Args: []string{"profiles", "switch", "test"},
		Data: make(map[string]interface{}),
	}
	err = cmd.Execute(ctx, exec)
	require.NoError(t, err)
	assert.Contains(t, exec.Data["output"], "Switched to profile: test")

	// List profiles again to verify switch
	exec = &command.ExecutionContext{
		Args: []string{"profiles", "list"},
		Data: make(map[string]interface{}),
	}
	err = cmd.Execute(ctx, exec)
	require.NoError(t, err)
	output = exec.Data["output"].(string)
	assert.Contains(t, output, "test (current)")

	// Export profile
	exec = &command.ExecutionContext{
		Args:  []string{"profiles", "export", "test"},
		Flags: map[string]interface{}{"format": "json"},
		Data:  make(map[string]interface{}),
	}
	err = cmd.Execute(ctx, exec)
	require.NoError(t, err)
	output = exec.Data["output"].(string)
	assert.Contains(t, output, "{")

	// Delete profile
	exec = &command.ExecutionContext{
		Args: []string{"profiles", "delete", "test"},
		Data: make(map[string]interface{}),
	}
	err = cmd.Execute(ctx, exec)
	require.NoError(t, err)
	assert.Contains(t, exec.Data["output"], "Deleted profile: test")
}

func TestConfigCommand_FormatSettings(t *testing.T) {
	settings := map[string]interface{}{
		"provider": "openai",
		"model":    "gpt-4",
		"api": map[string]interface{}{
			"openai": map[string]interface{}{
				"key":      "sk-test",
				"endpoint": "https://api.openai.com",
			},
		},
	}

	tests := []struct {
		name           string
		format         string
		expectedOutput []string
	}{
		{
			name:   "text format",
			format: "text",
			expectedOutput: []string{
				"Configuration settings:",
				"provider: openai",
				"model: gpt-4",
				"api:",
				"openai:",
				"key: sk-test",
			},
		},
		{
			name:   "json format",
			format: "json",
			expectedOutput: []string{
				"{",
				`"provider": "openai"`,
				`"model": "gpt-4"`,
				"}",
			},
		},
		{
			name:   "yaml format",
			format: "yaml",
			expectedOutput: []string{
				"provider: openai",
				"model: gpt-4",
				"api:",
				"  openai:",
				"    key: sk-test",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			output := formatSettings(settings, tt.format)
			for _, expected := range tt.expectedOutput {
				assert.Contains(t, output, expected)
			}
		})
	}
}

func TestConfigCommand_ImportExport(t *testing.T) {
	manager := createTestConfigManager(t)
	cmd := NewConfigCommand(manager)
	ctx := context.Background()

	// Set some values
	manager.SetDefaultProvider("anthropic")
	manager.SetDefaultModel("claude-3")

	// Export config
	exec := &command.ExecutionContext{
		Args:  []string{"export"},
		Flags: map[string]interface{}{"format": "json"},
		Data:  make(map[string]interface{}),
	}
	err := cmd.Execute(ctx, exec)
	require.NoError(t, err)
	
	exportedData := exec.Data["output"].(string)
	assert.Contains(t, exportedData, "anthropic")
	assert.Contains(t, exportedData, "claude-3")

	// Test import command (would need a real file in a real test)
	exec = &command.ExecutionContext{
		Args: []string{"import", "test-config.yaml"},
		Data: make(map[string]interface{}),
	}
	err = cmd.Execute(ctx, exec)
	// This will fail because the file doesn't exist, but we're testing the command structure
	require.Error(t, err)
	assert.Contains(t, err.Error(), "import failed")
}

func createTestConfigManager(t *testing.T) *config.Manager {
	// Create an in-memory config manager for testing
	opts := &config.Options{
		ConfigDirs: []string{t.TempDir()},
		EnvPrefix:  "TEST_",
	}
	
	manager, err := config.NewManager(opts)
	require.NoError(t, err)
	
	// Set some defaults
	manager.SetDefaultProvider("openai")
	manager.SetDefaultModel("gpt-3.5-turbo")
	
	return manager
}